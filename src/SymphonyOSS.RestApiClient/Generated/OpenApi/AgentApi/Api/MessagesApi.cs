// Licensed to the Symphony Software Foundation (SSF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The SSF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
/* 
 * Agent API
 *
 * This document refers to Symphony API calls to send and receive messages and content. They need the on-premise Agent installed to perform decryption/encryption of content.  - sessionToken and keyManagerToken can be obtained by calling the authenticationAPI on the symphony back end and the key manager respectively. Refer to the methods described in authenticatorAPI.yaml. - Actions are defined to be atomic, ie will succeed in their entirety or fail and have changed nothing. - If it returns a 40X status then it will have sent no message to any stream even if a request to aome subset of the requested streams would have succeeded. - If this contract cannot be met for any reason then this is an error and the response code will be 50X. - MessageML is a markup language for messages. See reference here: https://developers.symphony.com/documentation/message_format_reference 
 *
 * OpenAPI spec version: current
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp.Portable;
using SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client;
using SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Model;

namespace SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IMessagesApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Import messages from other systems into Symphony.
        /// </summary>
        /// <remarks>
        /// Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>ImportResponseList</returns>
        ImportResponseList V1MessageImportPost (string sessionToken, string keyManagerToken, MessageImportList messageList);

        /// <summary>
        /// Import messages from other systems into Symphony.
        /// </summary>
        /// <remarks>
        /// Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>ApiResponse of ImportResponseList</returns>
        ApiResponse<ImportResponseList> V1MessageImportPostWithHttpInfo (string sessionToken, string keyManagerToken, MessageImportList messageList);
        /// <summary>
        /// Search messages
        /// </summary>
        /// <remarks>
        /// Search messages according to the specified criteria. The \&quot;query\&quot; parameter takes a search query defined as \&quot;field:value\&quot; pairs combined by the operator \&quot;AND\&quot; (e.g. \&quot;text:foo AND autor:bar\&quot;). Supported fields are  (case-insensitive): \&quot;text\&quot;, \&quot;author\&quot;, \&quot;hashtag\&quot;, \&quot;cashtag\&quot;, \&quot;mention\&quot;, \&quot;signal\&quot;, \&quot;fromDate\&quot;, \&quot;toDate\&quot;,  \&quot;streamId\&quot;, \&quot;streamType\&quot;.  \&quot;text\&quot; search requires a \&quot;streamId\&quot; to be specified.  \&quot;streamType\&quot; accepts one of the following values: \&quot;chat\&quot; (IMs and MIMs), \&quot;im\&quot;, \&quot;mim\&quot;, \&quot;chatroom\&quot;, \&quot;post\&quot;.  \&quot;signal\&quot; queries can only be combined with \&quot;fromDate\&quot;, \&quot;toDate\&quot;, \&quot;skip\&quot; and \&quot;limit\&quot; parameters. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. See above for the query syntax. </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of results to skip.  (optional)</param>
        /// <param name="limit">Max no. of results to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <param name="scope">Describes where content should be searched for that query. It can exclusively apply to Symphony content or to one Connector.  (optional)</param>
        /// <returns>V4MessageList</returns>
        V4MessageList V1MessageSearchGet (string query, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null, string scope = null);

        /// <summary>
        /// Search messages
        /// </summary>
        /// <remarks>
        /// Search messages according to the specified criteria. The \&quot;query\&quot; parameter takes a search query defined as \&quot;field:value\&quot; pairs combined by the operator \&quot;AND\&quot; (e.g. \&quot;text:foo AND autor:bar\&quot;). Supported fields are  (case-insensitive): \&quot;text\&quot;, \&quot;author\&quot;, \&quot;hashtag\&quot;, \&quot;cashtag\&quot;, \&quot;mention\&quot;, \&quot;signal\&quot;, \&quot;fromDate\&quot;, \&quot;toDate\&quot;,  \&quot;streamId\&quot;, \&quot;streamType\&quot;.  \&quot;text\&quot; search requires a \&quot;streamId\&quot; to be specified.  \&quot;streamType\&quot; accepts one of the following values: \&quot;chat\&quot; (IMs and MIMs), \&quot;im\&quot;, \&quot;mim\&quot;, \&quot;chatroom\&quot;, \&quot;post\&quot;.  \&quot;signal\&quot; queries can only be combined with \&quot;fromDate\&quot;, \&quot;toDate\&quot;, \&quot;skip\&quot; and \&quot;limit\&quot; parameters. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. See above for the query syntax. </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of results to skip.  (optional)</param>
        /// <param name="limit">Max no. of results to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <param name="scope">Describes where content should be searched for that query. It can exclusively apply to Symphony content or to one Connector.  (optional)</param>
        /// <returns>ApiResponse of V4MessageList</returns>
        ApiResponse<V4MessageList> V1MessageSearchGetWithHttpInfo (string query, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null, string scope = null);
        /// <summary>
        /// Search messages
        /// </summary>
        /// <remarks>
        /// Search messages according to the specified criteria. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. See above for the query syntax. </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of results to skip.  (optional)</param>
        /// <param name="limit">Max no. of results to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <param name="scope">Describes where content should be searched for that query. It can exclusively apply to Symphony content or to one Connector.  (optional)</param>
        /// <returns>V4MessageList</returns>
        V4MessageList V1MessageSearchPost (MessageSearchQuery query, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null, string scope = null);

        /// <summary>
        /// Search messages
        /// </summary>
        /// <remarks>
        /// Search messages according to the specified criteria. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. See above for the query syntax. </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of results to skip.  (optional)</param>
        /// <param name="limit">Max no. of results to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <param name="scope">Describes where content should be searched for that query. It can exclusively apply to Symphony content or to one Connector.  (optional)</param>
        /// <returns>ApiResponse of V4MessageList</returns>
        ApiResponse<V4MessageList> V1MessageSearchPostWithHttpInfo (MessageSearchQuery query, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null, string scope = null);
        /// <summary>
        /// Post a message to one existing stream.
        /// </summary>
        /// <remarks>
        /// Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="message"></param>
        /// <returns>Message</returns>
        Message V1StreamSidMessageCreatePost (string sid, string sessionToken, string keyManagerToken, MessageSubmission message);

        /// <summary>
        /// Post a message to one existing stream.
        /// </summary>
        /// <remarks>
        /// Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="message"></param>
        /// <returns>ApiResponse of Message</returns>
        ApiResponse<Message> V1StreamSidMessageCreatePostWithHttpInfo (string sid, string sessionToken, string keyManagerToken, MessageSubmission message);
        /// <summary>
        /// Get messages from an existing stream.
        /// </summary>
        /// <remarks>
        /// A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="offset">No. of messages to skip.  (optional)</param>
        /// <param name="maxMessages">Max No. of messages to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <returns>MessageList</returns>
        MessageList V1StreamSidMessageGet (string sid, long? since, string sessionToken, string keyManagerToken, int? offset = null, int? maxMessages = null);

        /// <summary>
        /// Get messages from an existing stream.
        /// </summary>
        /// <remarks>
        /// A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="offset">No. of messages to skip.  (optional)</param>
        /// <param name="maxMessages">Max No. of messages to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <returns>ApiResponse of MessageList</returns>
        ApiResponse<MessageList> V1StreamSidMessageGetWithHttpInfo (string sid, long? since, string sessionToken, string keyManagerToken, int? offset = null, int? maxMessages = null);
        /// <summary>
        /// Import messages from other systems into Symphony.
        /// </summary>
        /// <remarks>
        /// Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. Optionally the original message ID can be specified to identify the imported message for the purpose of repeat imports. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>V2ImportResponseList</returns>
        V2ImportResponseList V2MessageImportPost (string sessionToken, string keyManagerToken, V2MessageImportList messageList);

        /// <summary>
        /// Import messages from other systems into Symphony.
        /// </summary>
        /// <remarks>
        /// Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. Optionally the original message ID can be specified to identify the imported message for the purpose of repeat imports. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>ApiResponse of V2ImportResponseList</returns>
        ApiResponse<V2ImportResponseList> V2MessageImportPostWithHttpInfo (string sessionToken, string keyManagerToken, V2MessageImportList messageList);
        /// <summary>
        /// Post a message to one existing stream.
        /// </summary>
        /// <remarks>
        /// Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message (see the V2MessageSubmission parameter).  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="message"></param>
        /// <returns>V2Message</returns>
        V2Message V2StreamSidMessageCreatePost (string sid, string sessionToken, string keyManagerToken, V2MessageSubmission message);

        /// <summary>
        /// Post a message to one existing stream.
        /// </summary>
        /// <remarks>
        /// Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message (see the V2MessageSubmission parameter).  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="message"></param>
        /// <returns>ApiResponse of V2Message</returns>
        ApiResponse<V2Message> V2StreamSidMessageCreatePostWithHttpInfo (string sid, string sessionToken, string keyManagerToken, V2MessageSubmission message);
        /// <summary>
        /// Get messages from an existing stream.
        /// </summary>
        /// <remarks>
        /// A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="offset">No. of messages to skip.  (optional)</param>
        /// <param name="limit">Max No. of messages to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <returns>V2MessageList</returns>
        V2MessageList V2StreamSidMessageGet (string sid, long? since, string sessionToken, string keyManagerToken, int? offset = null, int? limit = null);

        /// <summary>
        /// Get messages from an existing stream.
        /// </summary>
        /// <remarks>
        /// A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="offset">No. of messages to skip.  (optional)</param>
        /// <param name="limit">Max No. of messages to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <returns>ApiResponse of V2MessageList</returns>
        ApiResponse<V2MessageList> V2StreamSidMessageGetWithHttpInfo (string sid, long? since, string sessionToken, string keyManagerToken, int? offset = null, int? limit = null);
        /// <summary>
        /// PROVISIONAL - Post a message to one existing stream.
        /// </summary>
        /// <remarks>
        /// Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message (see the V2MessageSubmission parameter).  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned.  Regarding authentication, you must either use the sessionToken which was created for delegated app access or both the sessionToken and keyManagerToken together. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Authorization token used to make delegated calls.</param>
        /// <param name="message"></param>
        /// <param name="keyManagerToken">Key Manager authentication token. (optional)</param>
        /// <returns>V2Message</returns>
        V2Message V3StreamSidMessageCreatePost (string sid, string sessionToken, V2MessageSubmission message, string keyManagerToken = null);

        /// <summary>
        /// PROVISIONAL - Post a message to one existing stream.
        /// </summary>
        /// <remarks>
        /// Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message (see the V2MessageSubmission parameter).  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned.  Regarding authentication, you must either use the sessionToken which was created for delegated app access or both the sessionToken and keyManagerToken together. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Authorization token used to make delegated calls.</param>
        /// <param name="message"></param>
        /// <param name="keyManagerToken">Key Manager authentication token. (optional)</param>
        /// <returns>ApiResponse of V2Message</returns>
        ApiResponse<V2Message> V3StreamSidMessageCreatePostWithHttpInfo (string sid, string sessionToken, V2MessageSubmission message, string keyManagerToken = null);
        /// <summary>
        /// Import messages from other systems into Symphony.
        /// </summary>
        /// <remarks>
        /// Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. Optionally the original message ID can be specified to identify the imported message for the purpose of repeat imports. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>V4ImportResponseList</returns>
        V4ImportResponseList V4MessageImportPost (string sessionToken, string keyManagerToken, V4MessageImportList messageList);

        /// <summary>
        /// Import messages from other systems into Symphony.
        /// </summary>
        /// <remarks>
        /// Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. Optionally the original message ID can be specified to identify the imported message for the purpose of repeat imports. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>ApiResponse of V4ImportResponseList</returns>
        ApiResponse<V4ImportResponseList> V4MessageImportPostWithHttpInfo (string sessionToken, string keyManagerToken, V4MessageImportList messageList);
        /// <summary>
        /// Post a message to one existing stream.
        /// </summary>
        /// <remarks>
        /// Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message.  The message can be provided as MessageMLV2 or PresentationML. Both formats support Freemarker templates.  The optional parameter \&quot;data\&quot; can be used to provide a JSON payload containing entity data. If the message contains explicit references to entity data (in \&quot;data-entity-id\&quot; element attributes), this parameter is required.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned.  Regarding authentication, you must either use the sessionToken which was created for delegated app access or both the sessionToken and keyManagerToken together. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Authorization token used to make delegated calls.</param>
        /// <param name="message">The message payload in MessageML.</param>
        /// <param name="keyManagerToken">Key Manager authentication token. (optional)</param>
        /// <param name="data">Optional message data in EntityJSON. (optional)</param>
        /// <param name="version">Optional message version in the format \&quot;major.minor\&quot;. If empty, defaults to the latest supported version.  (optional)</param>
        /// <param name="attachment">Optional file attachment. (optional)</param>
        /// <returns>V4Message</returns>
        V4Message V4StreamSidMessageCreatePost (string sid, string sessionToken, string message, string keyManagerToken = null, string data = null, string version = null, System.IO.Stream attachment = null);

        /// <summary>
        /// Post a message to one existing stream.
        /// </summary>
        /// <remarks>
        /// Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message.  The message can be provided as MessageMLV2 or PresentationML. Both formats support Freemarker templates.  The optional parameter \&quot;data\&quot; can be used to provide a JSON payload containing entity data. If the message contains explicit references to entity data (in \&quot;data-entity-id\&quot; element attributes), this parameter is required.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned.  Regarding authentication, you must either use the sessionToken which was created for delegated app access or both the sessionToken and keyManagerToken together. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Authorization token used to make delegated calls.</param>
        /// <param name="message">The message payload in MessageML.</param>
        /// <param name="keyManagerToken">Key Manager authentication token. (optional)</param>
        /// <param name="data">Optional message data in EntityJSON. (optional)</param>
        /// <param name="version">Optional message version in the format \&quot;major.minor\&quot;. If empty, defaults to the latest supported version.  (optional)</param>
        /// <param name="attachment">Optional file attachment. (optional)</param>
        /// <returns>ApiResponse of V4Message</returns>
        ApiResponse<V4Message> V4StreamSidMessageCreatePostWithHttpInfo (string sid, string sessionToken, string message, string keyManagerToken = null, string data = null, string version = null, System.IO.Stream attachment = null);
        /// <summary>
        /// Get messages from an existing stream.
        /// </summary>
        /// <remarks>
        /// A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of messages to skip.  (optional)</param>
        /// <param name="limit">Max No. of messages to return. If no value is provided, 50 is the default. The maximum supported value is 500.  (optional)</param>
        /// <returns>V4MessageList</returns>
        V4MessageList V4StreamSidMessageGet (string sid, long? since, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null);

        /// <summary>
        /// Get messages from an existing stream.
        /// </summary>
        /// <remarks>
        /// A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of messages to skip.  (optional)</param>
        /// <param name="limit">Max No. of messages to return. If no value is provided, 50 is the default. The maximum supported value is 500.  (optional)</param>
        /// <returns>ApiResponse of V4MessageList</returns>
        ApiResponse<V4MessageList> V4StreamSidMessageGetWithHttpInfo (string sid, long? since, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Import messages from other systems into Symphony.
        /// </summary>
        /// <remarks>
        /// Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>Task of ImportResponseList</returns>
        System.Threading.Tasks.Task<ImportResponseList> V1MessageImportPostAsync (string sessionToken, string keyManagerToken, MessageImportList messageList);

        /// <summary>
        /// Import messages from other systems into Symphony.
        /// </summary>
        /// <remarks>
        /// Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>Task of ApiResponse (ImportResponseList)</returns>
        System.Threading.Tasks.Task<ApiResponse<ImportResponseList>> V1MessageImportPostAsyncWithHttpInfo (string sessionToken, string keyManagerToken, MessageImportList messageList);
        /// <summary>
        /// Search messages
        /// </summary>
        /// <remarks>
        /// Search messages according to the specified criteria. The \&quot;query\&quot; parameter takes a search query defined as \&quot;field:value\&quot; pairs combined by the operator \&quot;AND\&quot; (e.g. \&quot;text:foo AND autor:bar\&quot;). Supported fields are  (case-insensitive): \&quot;text\&quot;, \&quot;author\&quot;, \&quot;hashtag\&quot;, \&quot;cashtag\&quot;, \&quot;mention\&quot;, \&quot;signal\&quot;, \&quot;fromDate\&quot;, \&quot;toDate\&quot;,  \&quot;streamId\&quot;, \&quot;streamType\&quot;.  \&quot;text\&quot; search requires a \&quot;streamId\&quot; to be specified.  \&quot;streamType\&quot; accepts one of the following values: \&quot;chat\&quot; (IMs and MIMs), \&quot;im\&quot;, \&quot;mim\&quot;, \&quot;chatroom\&quot;, \&quot;post\&quot;.  \&quot;signal\&quot; queries can only be combined with \&quot;fromDate\&quot;, \&quot;toDate\&quot;, \&quot;skip\&quot; and \&quot;limit\&quot; parameters. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. See above for the query syntax. </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of results to skip.  (optional)</param>
        /// <param name="limit">Max no. of results to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <param name="scope">Describes where content should be searched for that query. It can exclusively apply to Symphony content or to one Connector.  (optional)</param>
        /// <returns>Task of V4MessageList</returns>
        System.Threading.Tasks.Task<V4MessageList> V1MessageSearchGetAsync (string query, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null, string scope = null);

        /// <summary>
        /// Search messages
        /// </summary>
        /// <remarks>
        /// Search messages according to the specified criteria. The \&quot;query\&quot; parameter takes a search query defined as \&quot;field:value\&quot; pairs combined by the operator \&quot;AND\&quot; (e.g. \&quot;text:foo AND autor:bar\&quot;). Supported fields are  (case-insensitive): \&quot;text\&quot;, \&quot;author\&quot;, \&quot;hashtag\&quot;, \&quot;cashtag\&quot;, \&quot;mention\&quot;, \&quot;signal\&quot;, \&quot;fromDate\&quot;, \&quot;toDate\&quot;,  \&quot;streamId\&quot;, \&quot;streamType\&quot;.  \&quot;text\&quot; search requires a \&quot;streamId\&quot; to be specified.  \&quot;streamType\&quot; accepts one of the following values: \&quot;chat\&quot; (IMs and MIMs), \&quot;im\&quot;, \&quot;mim\&quot;, \&quot;chatroom\&quot;, \&quot;post\&quot;.  \&quot;signal\&quot; queries can only be combined with \&quot;fromDate\&quot;, \&quot;toDate\&quot;, \&quot;skip\&quot; and \&quot;limit\&quot; parameters. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. See above for the query syntax. </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of results to skip.  (optional)</param>
        /// <param name="limit">Max no. of results to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <param name="scope">Describes where content should be searched for that query. It can exclusively apply to Symphony content or to one Connector.  (optional)</param>
        /// <returns>Task of ApiResponse (V4MessageList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V4MessageList>> V1MessageSearchGetAsyncWithHttpInfo (string query, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null, string scope = null);
        /// <summary>
        /// Search messages
        /// </summary>
        /// <remarks>
        /// Search messages according to the specified criteria. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. See above for the query syntax. </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of results to skip.  (optional)</param>
        /// <param name="limit">Max no. of results to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <param name="scope">Describes where content should be searched for that query. It can exclusively apply to Symphony content or to one Connector.  (optional)</param>
        /// <returns>Task of V4MessageList</returns>
        System.Threading.Tasks.Task<V4MessageList> V1MessageSearchPostAsync (MessageSearchQuery query, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null, string scope = null);

        /// <summary>
        /// Search messages
        /// </summary>
        /// <remarks>
        /// Search messages according to the specified criteria. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. See above for the query syntax. </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of results to skip.  (optional)</param>
        /// <param name="limit">Max no. of results to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <param name="scope">Describes where content should be searched for that query. It can exclusively apply to Symphony content or to one Connector.  (optional)</param>
        /// <returns>Task of ApiResponse (V4MessageList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V4MessageList>> V1MessageSearchPostAsyncWithHttpInfo (MessageSearchQuery query, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null, string scope = null);
        /// <summary>
        /// Post a message to one existing stream.
        /// </summary>
        /// <remarks>
        /// Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="message"></param>
        /// <returns>Task of Message</returns>
        System.Threading.Tasks.Task<Message> V1StreamSidMessageCreatePostAsync (string sid, string sessionToken, string keyManagerToken, MessageSubmission message);

        /// <summary>
        /// Post a message to one existing stream.
        /// </summary>
        /// <remarks>
        /// Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="message"></param>
        /// <returns>Task of ApiResponse (Message)</returns>
        System.Threading.Tasks.Task<ApiResponse<Message>> V1StreamSidMessageCreatePostAsyncWithHttpInfo (string sid, string sessionToken, string keyManagerToken, MessageSubmission message);
        /// <summary>
        /// Get messages from an existing stream.
        /// </summary>
        /// <remarks>
        /// A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="offset">No. of messages to skip.  (optional)</param>
        /// <param name="maxMessages">Max No. of messages to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <returns>Task of MessageList</returns>
        System.Threading.Tasks.Task<MessageList> V1StreamSidMessageGetAsync (string sid, long? since, string sessionToken, string keyManagerToken, int? offset = null, int? maxMessages = null);

        /// <summary>
        /// Get messages from an existing stream.
        /// </summary>
        /// <remarks>
        /// A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="offset">No. of messages to skip.  (optional)</param>
        /// <param name="maxMessages">Max No. of messages to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <returns>Task of ApiResponse (MessageList)</returns>
        System.Threading.Tasks.Task<ApiResponse<MessageList>> V1StreamSidMessageGetAsyncWithHttpInfo (string sid, long? since, string sessionToken, string keyManagerToken, int? offset = null, int? maxMessages = null);
        /// <summary>
        /// Import messages from other systems into Symphony.
        /// </summary>
        /// <remarks>
        /// Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. Optionally the original message ID can be specified to identify the imported message for the purpose of repeat imports. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>Task of V2ImportResponseList</returns>
        System.Threading.Tasks.Task<V2ImportResponseList> V2MessageImportPostAsync (string sessionToken, string keyManagerToken, V2MessageImportList messageList);

        /// <summary>
        /// Import messages from other systems into Symphony.
        /// </summary>
        /// <remarks>
        /// Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. Optionally the original message ID can be specified to identify the imported message for the purpose of repeat imports. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>Task of ApiResponse (V2ImportResponseList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V2ImportResponseList>> V2MessageImportPostAsyncWithHttpInfo (string sessionToken, string keyManagerToken, V2MessageImportList messageList);
        /// <summary>
        /// Post a message to one existing stream.
        /// </summary>
        /// <remarks>
        /// Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message (see the V2MessageSubmission parameter).  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="message"></param>
        /// <returns>Task of V2Message</returns>
        System.Threading.Tasks.Task<V2Message> V2StreamSidMessageCreatePostAsync (string sid, string sessionToken, string keyManagerToken, V2MessageSubmission message);

        /// <summary>
        /// Post a message to one existing stream.
        /// </summary>
        /// <remarks>
        /// Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message (see the V2MessageSubmission parameter).  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="message"></param>
        /// <returns>Task of ApiResponse (V2Message)</returns>
        System.Threading.Tasks.Task<ApiResponse<V2Message>> V2StreamSidMessageCreatePostAsyncWithHttpInfo (string sid, string sessionToken, string keyManagerToken, V2MessageSubmission message);
        /// <summary>
        /// Get messages from an existing stream.
        /// </summary>
        /// <remarks>
        /// A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="offset">No. of messages to skip.  (optional)</param>
        /// <param name="limit">Max No. of messages to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <returns>Task of V2MessageList</returns>
        System.Threading.Tasks.Task<V2MessageList> V2StreamSidMessageGetAsync (string sid, long? since, string sessionToken, string keyManagerToken, int? offset = null, int? limit = null);

        /// <summary>
        /// Get messages from an existing stream.
        /// </summary>
        /// <remarks>
        /// A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="offset">No. of messages to skip.  (optional)</param>
        /// <param name="limit">Max No. of messages to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <returns>Task of ApiResponse (V2MessageList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V2MessageList>> V2StreamSidMessageGetAsyncWithHttpInfo (string sid, long? since, string sessionToken, string keyManagerToken, int? offset = null, int? limit = null);
        /// <summary>
        /// PROVISIONAL - Post a message to one existing stream.
        /// </summary>
        /// <remarks>
        /// Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message (see the V2MessageSubmission parameter).  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned.  Regarding authentication, you must either use the sessionToken which was created for delegated app access or both the sessionToken and keyManagerToken together. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Authorization token used to make delegated calls.</param>
        /// <param name="message"></param>
        /// <param name="keyManagerToken">Key Manager authentication token. (optional)</param>
        /// <returns>Task of V2Message</returns>
        System.Threading.Tasks.Task<V2Message> V3StreamSidMessageCreatePostAsync (string sid, string sessionToken, V2MessageSubmission message, string keyManagerToken = null);

        /// <summary>
        /// PROVISIONAL - Post a message to one existing stream.
        /// </summary>
        /// <remarks>
        /// Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message (see the V2MessageSubmission parameter).  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned.  Regarding authentication, you must either use the sessionToken which was created for delegated app access or both the sessionToken and keyManagerToken together. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Authorization token used to make delegated calls.</param>
        /// <param name="message"></param>
        /// <param name="keyManagerToken">Key Manager authentication token. (optional)</param>
        /// <returns>Task of ApiResponse (V2Message)</returns>
        System.Threading.Tasks.Task<ApiResponse<V2Message>> V3StreamSidMessageCreatePostAsyncWithHttpInfo (string sid, string sessionToken, V2MessageSubmission message, string keyManagerToken = null);
        /// <summary>
        /// Import messages from other systems into Symphony.
        /// </summary>
        /// <remarks>
        /// Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. Optionally the original message ID can be specified to identify the imported message for the purpose of repeat imports. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>Task of V4ImportResponseList</returns>
        System.Threading.Tasks.Task<V4ImportResponseList> V4MessageImportPostAsync (string sessionToken, string keyManagerToken, V4MessageImportList messageList);

        /// <summary>
        /// Import messages from other systems into Symphony.
        /// </summary>
        /// <remarks>
        /// Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. Optionally the original message ID can be specified to identify the imported message for the purpose of repeat imports. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>Task of ApiResponse (V4ImportResponseList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V4ImportResponseList>> V4MessageImportPostAsyncWithHttpInfo (string sessionToken, string keyManagerToken, V4MessageImportList messageList);
        /// <summary>
        /// Post a message to one existing stream.
        /// </summary>
        /// <remarks>
        /// Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message.  The message can be provided as MessageMLV2 or PresentationML. Both formats support Freemarker templates.  The optional parameter \&quot;data\&quot; can be used to provide a JSON payload containing entity data. If the message contains explicit references to entity data (in \&quot;data-entity-id\&quot; element attributes), this parameter is required.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned.  Regarding authentication, you must either use the sessionToken which was created for delegated app access or both the sessionToken and keyManagerToken together. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Authorization token used to make delegated calls.</param>
        /// <param name="message">The message payload in MessageML.</param>
        /// <param name="keyManagerToken">Key Manager authentication token. (optional)</param>
        /// <param name="data">Optional message data in EntityJSON. (optional)</param>
        /// <param name="version">Optional message version in the format \&quot;major.minor\&quot;. If empty, defaults to the latest supported version.  (optional)</param>
        /// <param name="attachment">Optional file attachment. (optional)</param>
        /// <returns>Task of V4Message</returns>
        System.Threading.Tasks.Task<V4Message> V4StreamSidMessageCreatePostAsync (string sid, string sessionToken, string message, string keyManagerToken = null, string data = null, string version = null, System.IO.Stream attachment = null);

        /// <summary>
        /// Post a message to one existing stream.
        /// </summary>
        /// <remarks>
        /// Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message.  The message can be provided as MessageMLV2 or PresentationML. Both formats support Freemarker templates.  The optional parameter \&quot;data\&quot; can be used to provide a JSON payload containing entity data. If the message contains explicit references to entity data (in \&quot;data-entity-id\&quot; element attributes), this parameter is required.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned.  Regarding authentication, you must either use the sessionToken which was created for delegated app access or both the sessionToken and keyManagerToken together. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Authorization token used to make delegated calls.</param>
        /// <param name="message">The message payload in MessageML.</param>
        /// <param name="keyManagerToken">Key Manager authentication token. (optional)</param>
        /// <param name="data">Optional message data in EntityJSON. (optional)</param>
        /// <param name="version">Optional message version in the format \&quot;major.minor\&quot;. If empty, defaults to the latest supported version.  (optional)</param>
        /// <param name="attachment">Optional file attachment. (optional)</param>
        /// <returns>Task of ApiResponse (V4Message)</returns>
        System.Threading.Tasks.Task<ApiResponse<V4Message>> V4StreamSidMessageCreatePostAsyncWithHttpInfo (string sid, string sessionToken, string message, string keyManagerToken = null, string data = null, string version = null, System.IO.Stream attachment = null);
        /// <summary>
        /// Get messages from an existing stream.
        /// </summary>
        /// <remarks>
        /// A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of messages to skip.  (optional)</param>
        /// <param name="limit">Max No. of messages to return. If no value is provided, 50 is the default. The maximum supported value is 500.  (optional)</param>
        /// <returns>Task of V4MessageList</returns>
        System.Threading.Tasks.Task<V4MessageList> V4StreamSidMessageGetAsync (string sid, long? since, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null);

        /// <summary>
        /// Get messages from an existing stream.
        /// </summary>
        /// <remarks>
        /// A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </remarks>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of messages to skip.  (optional)</param>
        /// <param name="limit">Max No. of messages to return. If no value is provided, 50 is the default. The maximum supported value is 500.  (optional)</param>
        /// <returns>Task of ApiResponse (V4MessageList)</returns>
        System.Threading.Tasks.Task<ApiResponse<V4MessageList>> V4StreamSidMessageGetAsyncWithHttpInfo (string sid, long? since, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class MessagesApi : IMessagesApi
    {
        private SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="MessagesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public MessagesApi(String basePath)
        {
            this.Configuration = new Configuration { BasePath = basePath };

            ExceptionFactory = SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MessagesApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public MessagesApi(Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Import messages from other systems into Symphony. Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>ImportResponseList</returns>
        public ImportResponseList V1MessageImportPost (string sessionToken, string keyManagerToken, MessageImportList messageList)
        {
             ApiResponse<ImportResponseList> localVarResponse = V1MessageImportPostWithHttpInfo(sessionToken, keyManagerToken, messageList);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Import messages from other systems into Symphony. Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>ApiResponse of ImportResponseList</returns>
        public ApiResponse< ImportResponseList > V1MessageImportPostWithHttpInfo (string sessionToken, string keyManagerToken, MessageImportList messageList)
        {
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V1MessageImportPost");
            // verify the required parameter 'keyManagerToken' is set
            if (keyManagerToken == null)
                throw new ApiException(400, "Missing required parameter 'keyManagerToken' when calling MessagesApi->V1MessageImportPost");
            // verify the required parameter 'messageList' is set
            if (messageList == null)
                throw new ApiException(400, "Missing required parameter 'messageList' when calling MessagesApi->V1MessageImportPost");

            var localVarPath = "./v1/message/import";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter
            if (messageList != null && messageList.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(messageList); // http body (model) parameter
            }
            else
            {
                localVarPostBody = messageList; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V1MessageImportPost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ImportResponseList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (ImportResponseList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(ImportResponseList)));
        }

        /// <summary>
        /// Import messages from other systems into Symphony. Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>Task of ImportResponseList</returns>
        public async System.Threading.Tasks.Task<ImportResponseList> V1MessageImportPostAsync (string sessionToken, string keyManagerToken, MessageImportList messageList)
        {
             ApiResponse<ImportResponseList> localVarResponse = await V1MessageImportPostAsyncWithHttpInfo(sessionToken, keyManagerToken, messageList);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Import messages from other systems into Symphony. Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>Task of ApiResponse (ImportResponseList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ImportResponseList>> V1MessageImportPostAsyncWithHttpInfo (string sessionToken, string keyManagerToken, MessageImportList messageList)
        {
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V1MessageImportPost");
            // verify the required parameter 'keyManagerToken' is set
            if (keyManagerToken == null)
                throw new ApiException(400, "Missing required parameter 'keyManagerToken' when calling MessagesApi->V1MessageImportPost");
            // verify the required parameter 'messageList' is set
            if (messageList == null)
                throw new ApiException(400, "Missing required parameter 'messageList' when calling MessagesApi->V1MessageImportPost");

            var localVarPath = "./v1/message/import";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter
            if (messageList != null && messageList.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(messageList); // http body (model) parameter
            }
            else
            {
                localVarPostBody = messageList; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V1MessageImportPost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ImportResponseList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (ImportResponseList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(ImportResponseList)));
        }

        /// <summary>
        /// Search messages Search messages according to the specified criteria. The \&quot;query\&quot; parameter takes a search query defined as \&quot;field:value\&quot; pairs combined by the operator \&quot;AND\&quot; (e.g. \&quot;text:foo AND autor:bar\&quot;). Supported fields are  (case-insensitive): \&quot;text\&quot;, \&quot;author\&quot;, \&quot;hashtag\&quot;, \&quot;cashtag\&quot;, \&quot;mention\&quot;, \&quot;signal\&quot;, \&quot;fromDate\&quot;, \&quot;toDate\&quot;,  \&quot;streamId\&quot;, \&quot;streamType\&quot;.  \&quot;text\&quot; search requires a \&quot;streamId\&quot; to be specified.  \&quot;streamType\&quot; accepts one of the following values: \&quot;chat\&quot; (IMs and MIMs), \&quot;im\&quot;, \&quot;mim\&quot;, \&quot;chatroom\&quot;, \&quot;post\&quot;.  \&quot;signal\&quot; queries can only be combined with \&quot;fromDate\&quot;, \&quot;toDate\&quot;, \&quot;skip\&quot; and \&quot;limit\&quot; parameters. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. See above for the query syntax. </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of results to skip.  (optional)</param>
        /// <param name="limit">Max no. of results to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <param name="scope">Describes where content should be searched for that query. It can exclusively apply to Symphony content or to one Connector.  (optional)</param>
        /// <returns>V4MessageList</returns>
        public V4MessageList V1MessageSearchGet (string query, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null, string scope = null)
        {
             ApiResponse<V4MessageList> localVarResponse = V1MessageSearchGetWithHttpInfo(query, sessionToken, keyManagerToken, skip, limit, scope);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Search messages Search messages according to the specified criteria. The \&quot;query\&quot; parameter takes a search query defined as \&quot;field:value\&quot; pairs combined by the operator \&quot;AND\&quot; (e.g. \&quot;text:foo AND autor:bar\&quot;). Supported fields are  (case-insensitive): \&quot;text\&quot;, \&quot;author\&quot;, \&quot;hashtag\&quot;, \&quot;cashtag\&quot;, \&quot;mention\&quot;, \&quot;signal\&quot;, \&quot;fromDate\&quot;, \&quot;toDate\&quot;,  \&quot;streamId\&quot;, \&quot;streamType\&quot;.  \&quot;text\&quot; search requires a \&quot;streamId\&quot; to be specified.  \&quot;streamType\&quot; accepts one of the following values: \&quot;chat\&quot; (IMs and MIMs), \&quot;im\&quot;, \&quot;mim\&quot;, \&quot;chatroom\&quot;, \&quot;post\&quot;.  \&quot;signal\&quot; queries can only be combined with \&quot;fromDate\&quot;, \&quot;toDate\&quot;, \&quot;skip\&quot; and \&quot;limit\&quot; parameters. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. See above for the query syntax. </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of results to skip.  (optional)</param>
        /// <param name="limit">Max no. of results to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <param name="scope">Describes where content should be searched for that query. It can exclusively apply to Symphony content or to one Connector.  (optional)</param>
        /// <returns>ApiResponse of V4MessageList</returns>
        public ApiResponse< V4MessageList > V1MessageSearchGetWithHttpInfo (string query, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null, string scope = null)
        {
            // verify the required parameter 'query' is set
            if (query == null)
                throw new ApiException(400, "Missing required parameter 'query' when calling MessagesApi->V1MessageSearchGet");
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V1MessageSearchGet");
            // verify the required parameter 'keyManagerToken' is set
            if (keyManagerToken == null)
                throw new ApiException(400, "Missing required parameter 'keyManagerToken' when calling MessagesApi->V1MessageSearchGet");

            var localVarPath = "./v1/message/search";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (query != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "query", query)); // query parameter
            if (skip != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "skip", skip)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (scope != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "scope", scope)); // query parameter
            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V1MessageSearchGet", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V4MessageList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (V4MessageList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V4MessageList)));
        }

        /// <summary>
        /// Search messages Search messages according to the specified criteria. The \&quot;query\&quot; parameter takes a search query defined as \&quot;field:value\&quot; pairs combined by the operator \&quot;AND\&quot; (e.g. \&quot;text:foo AND autor:bar\&quot;). Supported fields are  (case-insensitive): \&quot;text\&quot;, \&quot;author\&quot;, \&quot;hashtag\&quot;, \&quot;cashtag\&quot;, \&quot;mention\&quot;, \&quot;signal\&quot;, \&quot;fromDate\&quot;, \&quot;toDate\&quot;,  \&quot;streamId\&quot;, \&quot;streamType\&quot;.  \&quot;text\&quot; search requires a \&quot;streamId\&quot; to be specified.  \&quot;streamType\&quot; accepts one of the following values: \&quot;chat\&quot; (IMs and MIMs), \&quot;im\&quot;, \&quot;mim\&quot;, \&quot;chatroom\&quot;, \&quot;post\&quot;.  \&quot;signal\&quot; queries can only be combined with \&quot;fromDate\&quot;, \&quot;toDate\&quot;, \&quot;skip\&quot; and \&quot;limit\&quot; parameters. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. See above for the query syntax. </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of results to skip.  (optional)</param>
        /// <param name="limit">Max no. of results to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <param name="scope">Describes where content should be searched for that query. It can exclusively apply to Symphony content or to one Connector.  (optional)</param>
        /// <returns>Task of V4MessageList</returns>
        public async System.Threading.Tasks.Task<V4MessageList> V1MessageSearchGetAsync (string query, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null, string scope = null)
        {
             ApiResponse<V4MessageList> localVarResponse = await V1MessageSearchGetAsyncWithHttpInfo(query, sessionToken, keyManagerToken, skip, limit, scope);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Search messages Search messages according to the specified criteria. The \&quot;query\&quot; parameter takes a search query defined as \&quot;field:value\&quot; pairs combined by the operator \&quot;AND\&quot; (e.g. \&quot;text:foo AND autor:bar\&quot;). Supported fields are  (case-insensitive): \&quot;text\&quot;, \&quot;author\&quot;, \&quot;hashtag\&quot;, \&quot;cashtag\&quot;, \&quot;mention\&quot;, \&quot;signal\&quot;, \&quot;fromDate\&quot;, \&quot;toDate\&quot;,  \&quot;streamId\&quot;, \&quot;streamType\&quot;.  \&quot;text\&quot; search requires a \&quot;streamId\&quot; to be specified.  \&quot;streamType\&quot; accepts one of the following values: \&quot;chat\&quot; (IMs and MIMs), \&quot;im\&quot;, \&quot;mim\&quot;, \&quot;chatroom\&quot;, \&quot;post\&quot;.  \&quot;signal\&quot; queries can only be combined with \&quot;fromDate\&quot;, \&quot;toDate\&quot;, \&quot;skip\&quot; and \&quot;limit\&quot; parameters. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. See above for the query syntax. </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of results to skip.  (optional)</param>
        /// <param name="limit">Max no. of results to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <param name="scope">Describes where content should be searched for that query. It can exclusively apply to Symphony content or to one Connector.  (optional)</param>
        /// <returns>Task of ApiResponse (V4MessageList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V4MessageList>> V1MessageSearchGetAsyncWithHttpInfo (string query, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null, string scope = null)
        {
            // verify the required parameter 'query' is set
            if (query == null)
                throw new ApiException(400, "Missing required parameter 'query' when calling MessagesApi->V1MessageSearchGet");
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V1MessageSearchGet");
            // verify the required parameter 'keyManagerToken' is set
            if (keyManagerToken == null)
                throw new ApiException(400, "Missing required parameter 'keyManagerToken' when calling MessagesApi->V1MessageSearchGet");

            var localVarPath = "./v1/message/search";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (query != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "query", query)); // query parameter
            if (skip != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "skip", skip)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (scope != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "scope", scope)); // query parameter
            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V1MessageSearchGet", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V4MessageList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (V4MessageList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V4MessageList)));
        }

        /// <summary>
        /// Search messages Search messages according to the specified criteria. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. See above for the query syntax. </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of results to skip.  (optional)</param>
        /// <param name="limit">Max no. of results to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <param name="scope">Describes where content should be searched for that query. It can exclusively apply to Symphony content or to one Connector.  (optional)</param>
        /// <returns>V4MessageList</returns>
        public V4MessageList V1MessageSearchPost (MessageSearchQuery query, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null, string scope = null)
        {
             ApiResponse<V4MessageList> localVarResponse = V1MessageSearchPostWithHttpInfo(query, sessionToken, keyManagerToken, skip, limit, scope);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Search messages Search messages according to the specified criteria. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. See above for the query syntax. </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of results to skip.  (optional)</param>
        /// <param name="limit">Max no. of results to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <param name="scope">Describes where content should be searched for that query. It can exclusively apply to Symphony content or to one Connector.  (optional)</param>
        /// <returns>ApiResponse of V4MessageList</returns>
        public ApiResponse< V4MessageList > V1MessageSearchPostWithHttpInfo (MessageSearchQuery query, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null, string scope = null)
        {
            // verify the required parameter 'query' is set
            if (query == null)
                throw new ApiException(400, "Missing required parameter 'query' when calling MessagesApi->V1MessageSearchPost");
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V1MessageSearchPost");
            // verify the required parameter 'keyManagerToken' is set
            if (keyManagerToken == null)
                throw new ApiException(400, "Missing required parameter 'keyManagerToken' when calling MessagesApi->V1MessageSearchPost");

            var localVarPath = "./v1/message/search";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (skip != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "skip", skip)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (scope != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "scope", scope)); // query parameter
            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter
            if (query != null && query.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(query); // http body (model) parameter
            }
            else
            {
                localVarPostBody = query; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V1MessageSearchPost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V4MessageList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (V4MessageList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V4MessageList)));
        }

        /// <summary>
        /// Search messages Search messages according to the specified criteria. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. See above for the query syntax. </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of results to skip.  (optional)</param>
        /// <param name="limit">Max no. of results to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <param name="scope">Describes where content should be searched for that query. It can exclusively apply to Symphony content or to one Connector.  (optional)</param>
        /// <returns>Task of V4MessageList</returns>
        public async System.Threading.Tasks.Task<V4MessageList> V1MessageSearchPostAsync (MessageSearchQuery query, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null, string scope = null)
        {
             ApiResponse<V4MessageList> localVarResponse = await V1MessageSearchPostAsyncWithHttpInfo(query, sessionToken, keyManagerToken, skip, limit, scope);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Search messages Search messages according to the specified criteria. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">The search query. See above for the query syntax. </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of results to skip.  (optional)</param>
        /// <param name="limit">Max no. of results to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <param name="scope">Describes where content should be searched for that query. It can exclusively apply to Symphony content or to one Connector.  (optional)</param>
        /// <returns>Task of ApiResponse (V4MessageList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V4MessageList>> V1MessageSearchPostAsyncWithHttpInfo (MessageSearchQuery query, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null, string scope = null)
        {
            // verify the required parameter 'query' is set
            if (query == null)
                throw new ApiException(400, "Missing required parameter 'query' when calling MessagesApi->V1MessageSearchPost");
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V1MessageSearchPost");
            // verify the required parameter 'keyManagerToken' is set
            if (keyManagerToken == null)
                throw new ApiException(400, "Missing required parameter 'keyManagerToken' when calling MessagesApi->V1MessageSearchPost");

            var localVarPath = "./v1/message/search";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (skip != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "skip", skip)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (scope != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "scope", scope)); // query parameter
            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter
            if (query != null && query.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(query); // http body (model) parameter
            }
            else
            {
                localVarPostBody = query; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V1MessageSearchPost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V4MessageList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (V4MessageList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V4MessageList)));
        }

        /// <summary>
        /// Post a message to one existing stream. Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="message"></param>
        /// <returns>Message</returns>
        public Message V1StreamSidMessageCreatePost (string sid, string sessionToken, string keyManagerToken, MessageSubmission message)
        {
             ApiResponse<Message> localVarResponse = V1StreamSidMessageCreatePostWithHttpInfo(sid, sessionToken, keyManagerToken, message);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Post a message to one existing stream. Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="message"></param>
        /// <returns>ApiResponse of Message</returns>
        public ApiResponse< Message > V1StreamSidMessageCreatePostWithHttpInfo (string sid, string sessionToken, string keyManagerToken, MessageSubmission message)
        {
            // verify the required parameter 'sid' is set
            if (sid == null)
                throw new ApiException(400, "Missing required parameter 'sid' when calling MessagesApi->V1StreamSidMessageCreatePost");
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V1StreamSidMessageCreatePost");
            // verify the required parameter 'keyManagerToken' is set
            if (keyManagerToken == null)
                throw new ApiException(400, "Missing required parameter 'keyManagerToken' when calling MessagesApi->V1StreamSidMessageCreatePost");
            // verify the required parameter 'message' is set
            if (message == null)
                throw new ApiException(400, "Missing required parameter 'message' when calling MessagesApi->V1StreamSidMessageCreatePost");

            var localVarPath = "./v1/stream/{sid}/message/create";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sid != null) localVarPathParams.Add("sid", Configuration.ApiClient.ParameterToString(sid)); // path parameter
            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter
            if (message != null && message.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(message); // http body (model) parameter
            }
            else
            {
                localVarPostBody = message; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V1StreamSidMessageCreatePost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Message>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (Message) Configuration.ApiClient.Deserialize(localVarResponse, typeof(Message)));
        }

        /// <summary>
        /// Post a message to one existing stream. Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="message"></param>
        /// <returns>Task of Message</returns>
        public async System.Threading.Tasks.Task<Message> V1StreamSidMessageCreatePostAsync (string sid, string sessionToken, string keyManagerToken, MessageSubmission message)
        {
             ApiResponse<Message> localVarResponse = await V1StreamSidMessageCreatePostAsyncWithHttpInfo(sid, sessionToken, keyManagerToken, message);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Post a message to one existing stream. Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="message"></param>
        /// <returns>Task of ApiResponse (Message)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Message>> V1StreamSidMessageCreatePostAsyncWithHttpInfo (string sid, string sessionToken, string keyManagerToken, MessageSubmission message)
        {
            // verify the required parameter 'sid' is set
            if (sid == null)
                throw new ApiException(400, "Missing required parameter 'sid' when calling MessagesApi->V1StreamSidMessageCreatePost");
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V1StreamSidMessageCreatePost");
            // verify the required parameter 'keyManagerToken' is set
            if (keyManagerToken == null)
                throw new ApiException(400, "Missing required parameter 'keyManagerToken' when calling MessagesApi->V1StreamSidMessageCreatePost");
            // verify the required parameter 'message' is set
            if (message == null)
                throw new ApiException(400, "Missing required parameter 'message' when calling MessagesApi->V1StreamSidMessageCreatePost");

            var localVarPath = "./v1/stream/{sid}/message/create";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sid != null) localVarPathParams.Add("sid", Configuration.ApiClient.ParameterToString(sid)); // path parameter
            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter
            if (message != null && message.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(message); // http body (model) parameter
            }
            else
            {
                localVarPostBody = message; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V1StreamSidMessageCreatePost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Message>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (Message) Configuration.ApiClient.Deserialize(localVarResponse, typeof(Message)));
        }

        /// <summary>
        /// Get messages from an existing stream. A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="offset">No. of messages to skip.  (optional)</param>
        /// <param name="maxMessages">Max No. of messages to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <returns>MessageList</returns>
        public MessageList V1StreamSidMessageGet (string sid, long? since, string sessionToken, string keyManagerToken, int? offset = null, int? maxMessages = null)
        {
             ApiResponse<MessageList> localVarResponse = V1StreamSidMessageGetWithHttpInfo(sid, since, sessionToken, keyManagerToken, offset, maxMessages);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get messages from an existing stream. A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="offset">No. of messages to skip.  (optional)</param>
        /// <param name="maxMessages">Max No. of messages to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <returns>ApiResponse of MessageList</returns>
        public ApiResponse< MessageList > V1StreamSidMessageGetWithHttpInfo (string sid, long? since, string sessionToken, string keyManagerToken, int? offset = null, int? maxMessages = null)
        {
            // verify the required parameter 'sid' is set
            if (sid == null)
                throw new ApiException(400, "Missing required parameter 'sid' when calling MessagesApi->V1StreamSidMessageGet");
            // verify the required parameter 'since' is set
            if (since == null)
                throw new ApiException(400, "Missing required parameter 'since' when calling MessagesApi->V1StreamSidMessageGet");
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V1StreamSidMessageGet");
            // verify the required parameter 'keyManagerToken' is set
            if (keyManagerToken == null)
                throw new ApiException(400, "Missing required parameter 'keyManagerToken' when calling MessagesApi->V1StreamSidMessageGet");

            var localVarPath = "./v1/stream/{sid}/message";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sid != null) localVarPathParams.Add("sid", Configuration.ApiClient.ParameterToString(sid)); // path parameter
            if (since != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "since", since)); // query parameter
            if (offset != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "offset", offset)); // query parameter
            if (maxMessages != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "maxMessages", maxMessages)); // query parameter
            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V1StreamSidMessageGet", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<MessageList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (MessageList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(MessageList)));
        }

        /// <summary>
        /// Get messages from an existing stream. A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="offset">No. of messages to skip.  (optional)</param>
        /// <param name="maxMessages">Max No. of messages to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <returns>Task of MessageList</returns>
        public async System.Threading.Tasks.Task<MessageList> V1StreamSidMessageGetAsync (string sid, long? since, string sessionToken, string keyManagerToken, int? offset = null, int? maxMessages = null)
        {
             ApiResponse<MessageList> localVarResponse = await V1StreamSidMessageGetAsyncWithHttpInfo(sid, since, sessionToken, keyManagerToken, offset, maxMessages);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get messages from an existing stream. A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="offset">No. of messages to skip.  (optional)</param>
        /// <param name="maxMessages">Max No. of messages to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <returns>Task of ApiResponse (MessageList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<MessageList>> V1StreamSidMessageGetAsyncWithHttpInfo (string sid, long? since, string sessionToken, string keyManagerToken, int? offset = null, int? maxMessages = null)
        {
            // verify the required parameter 'sid' is set
            if (sid == null)
                throw new ApiException(400, "Missing required parameter 'sid' when calling MessagesApi->V1StreamSidMessageGet");
            // verify the required parameter 'since' is set
            if (since == null)
                throw new ApiException(400, "Missing required parameter 'since' when calling MessagesApi->V1StreamSidMessageGet");
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V1StreamSidMessageGet");
            // verify the required parameter 'keyManagerToken' is set
            if (keyManagerToken == null)
                throw new ApiException(400, "Missing required parameter 'keyManagerToken' when calling MessagesApi->V1StreamSidMessageGet");

            var localVarPath = "./v1/stream/{sid}/message";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sid != null) localVarPathParams.Add("sid", Configuration.ApiClient.ParameterToString(sid)); // path parameter
            if (since != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "since", since)); // query parameter
            if (offset != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "offset", offset)); // query parameter
            if (maxMessages != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "maxMessages", maxMessages)); // query parameter
            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V1StreamSidMessageGet", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<MessageList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (MessageList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(MessageList)));
        }

        /// <summary>
        /// Import messages from other systems into Symphony. Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. Optionally the original message ID can be specified to identify the imported message for the purpose of repeat imports. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>V2ImportResponseList</returns>
        public V2ImportResponseList V2MessageImportPost (string sessionToken, string keyManagerToken, V2MessageImportList messageList)
        {
             ApiResponse<V2ImportResponseList> localVarResponse = V2MessageImportPostWithHttpInfo(sessionToken, keyManagerToken, messageList);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Import messages from other systems into Symphony. Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. Optionally the original message ID can be specified to identify the imported message for the purpose of repeat imports. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>ApiResponse of V2ImportResponseList</returns>
        public ApiResponse< V2ImportResponseList > V2MessageImportPostWithHttpInfo (string sessionToken, string keyManagerToken, V2MessageImportList messageList)
        {
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V2MessageImportPost");
            // verify the required parameter 'keyManagerToken' is set
            if (keyManagerToken == null)
                throw new ApiException(400, "Missing required parameter 'keyManagerToken' when calling MessagesApi->V2MessageImportPost");
            // verify the required parameter 'messageList' is set
            if (messageList == null)
                throw new ApiException(400, "Missing required parameter 'messageList' when calling MessagesApi->V2MessageImportPost");

            var localVarPath = "./v2/message/import";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter
            if (messageList != null && messageList.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(messageList); // http body (model) parameter
            }
            else
            {
                localVarPostBody = messageList; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V2MessageImportPost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V2ImportResponseList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (V2ImportResponseList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V2ImportResponseList)));
        }

        /// <summary>
        /// Import messages from other systems into Symphony. Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. Optionally the original message ID can be specified to identify the imported message for the purpose of repeat imports. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>Task of V2ImportResponseList</returns>
        public async System.Threading.Tasks.Task<V2ImportResponseList> V2MessageImportPostAsync (string sessionToken, string keyManagerToken, V2MessageImportList messageList)
        {
             ApiResponse<V2ImportResponseList> localVarResponse = await V2MessageImportPostAsyncWithHttpInfo(sessionToken, keyManagerToken, messageList);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Import messages from other systems into Symphony. Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. Optionally the original message ID can be specified to identify the imported message for the purpose of repeat imports. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>Task of ApiResponse (V2ImportResponseList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V2ImportResponseList>> V2MessageImportPostAsyncWithHttpInfo (string sessionToken, string keyManagerToken, V2MessageImportList messageList)
        {
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V2MessageImportPost");
            // verify the required parameter 'keyManagerToken' is set
            if (keyManagerToken == null)
                throw new ApiException(400, "Missing required parameter 'keyManagerToken' when calling MessagesApi->V2MessageImportPost");
            // verify the required parameter 'messageList' is set
            if (messageList == null)
                throw new ApiException(400, "Missing required parameter 'messageList' when calling MessagesApi->V2MessageImportPost");

            var localVarPath = "./v2/message/import";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter
            if (messageList != null && messageList.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(messageList); // http body (model) parameter
            }
            else
            {
                localVarPostBody = messageList; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V2MessageImportPost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V2ImportResponseList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (V2ImportResponseList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V2ImportResponseList)));
        }

        /// <summary>
        /// Post a message to one existing stream. Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message (see the V2MessageSubmission parameter).  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="message"></param>
        /// <returns>V2Message</returns>
        public V2Message V2StreamSidMessageCreatePost (string sid, string sessionToken, string keyManagerToken, V2MessageSubmission message)
        {
             ApiResponse<V2Message> localVarResponse = V2StreamSidMessageCreatePostWithHttpInfo(sid, sessionToken, keyManagerToken, message);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Post a message to one existing stream. Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message (see the V2MessageSubmission parameter).  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="message"></param>
        /// <returns>ApiResponse of V2Message</returns>
        public ApiResponse< V2Message > V2StreamSidMessageCreatePostWithHttpInfo (string sid, string sessionToken, string keyManagerToken, V2MessageSubmission message)
        {
            // verify the required parameter 'sid' is set
            if (sid == null)
                throw new ApiException(400, "Missing required parameter 'sid' when calling MessagesApi->V2StreamSidMessageCreatePost");
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V2StreamSidMessageCreatePost");
            // verify the required parameter 'keyManagerToken' is set
            if (keyManagerToken == null)
                throw new ApiException(400, "Missing required parameter 'keyManagerToken' when calling MessagesApi->V2StreamSidMessageCreatePost");
            // verify the required parameter 'message' is set
            if (message == null)
                throw new ApiException(400, "Missing required parameter 'message' when calling MessagesApi->V2StreamSidMessageCreatePost");

            var localVarPath = "./v2/stream/{sid}/message/create";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sid != null) localVarPathParams.Add("sid", Configuration.ApiClient.ParameterToString(sid)); // path parameter
            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter
            if (message != null && message.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(message); // http body (model) parameter
            }
            else
            {
                localVarPostBody = message; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V2StreamSidMessageCreatePost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V2Message>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (V2Message) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V2Message)));
        }

        /// <summary>
        /// Post a message to one existing stream. Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message (see the V2MessageSubmission parameter).  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="message"></param>
        /// <returns>Task of V2Message</returns>
        public async System.Threading.Tasks.Task<V2Message> V2StreamSidMessageCreatePostAsync (string sid, string sessionToken, string keyManagerToken, V2MessageSubmission message)
        {
             ApiResponse<V2Message> localVarResponse = await V2StreamSidMessageCreatePostAsyncWithHttpInfo(sid, sessionToken, keyManagerToken, message);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Post a message to one existing stream. Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message (see the V2MessageSubmission parameter).  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="message"></param>
        /// <returns>Task of ApiResponse (V2Message)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V2Message>> V2StreamSidMessageCreatePostAsyncWithHttpInfo (string sid, string sessionToken, string keyManagerToken, V2MessageSubmission message)
        {
            // verify the required parameter 'sid' is set
            if (sid == null)
                throw new ApiException(400, "Missing required parameter 'sid' when calling MessagesApi->V2StreamSidMessageCreatePost");
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V2StreamSidMessageCreatePost");
            // verify the required parameter 'keyManagerToken' is set
            if (keyManagerToken == null)
                throw new ApiException(400, "Missing required parameter 'keyManagerToken' when calling MessagesApi->V2StreamSidMessageCreatePost");
            // verify the required parameter 'message' is set
            if (message == null)
                throw new ApiException(400, "Missing required parameter 'message' when calling MessagesApi->V2StreamSidMessageCreatePost");

            var localVarPath = "./v2/stream/{sid}/message/create";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sid != null) localVarPathParams.Add("sid", Configuration.ApiClient.ParameterToString(sid)); // path parameter
            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter
            if (message != null && message.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(message); // http body (model) parameter
            }
            else
            {
                localVarPostBody = message; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V2StreamSidMessageCreatePost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V2Message>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (V2Message) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V2Message)));
        }

        /// <summary>
        /// Get messages from an existing stream. A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="offset">No. of messages to skip.  (optional)</param>
        /// <param name="limit">Max No. of messages to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <returns>V2MessageList</returns>
        public V2MessageList V2StreamSidMessageGet (string sid, long? since, string sessionToken, string keyManagerToken, int? offset = null, int? limit = null)
        {
             ApiResponse<V2MessageList> localVarResponse = V2StreamSidMessageGetWithHttpInfo(sid, since, sessionToken, keyManagerToken, offset, limit);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get messages from an existing stream. A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="offset">No. of messages to skip.  (optional)</param>
        /// <param name="limit">Max No. of messages to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <returns>ApiResponse of V2MessageList</returns>
        public ApiResponse< V2MessageList > V2StreamSidMessageGetWithHttpInfo (string sid, long? since, string sessionToken, string keyManagerToken, int? offset = null, int? limit = null)
        {
            // verify the required parameter 'sid' is set
            if (sid == null)
                throw new ApiException(400, "Missing required parameter 'sid' when calling MessagesApi->V2StreamSidMessageGet");
            // verify the required parameter 'since' is set
            if (since == null)
                throw new ApiException(400, "Missing required parameter 'since' when calling MessagesApi->V2StreamSidMessageGet");
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V2StreamSidMessageGet");
            // verify the required parameter 'keyManagerToken' is set
            if (keyManagerToken == null)
                throw new ApiException(400, "Missing required parameter 'keyManagerToken' when calling MessagesApi->V2StreamSidMessageGet");

            var localVarPath = "./v2/stream/{sid}/message";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sid != null) localVarPathParams.Add("sid", Configuration.ApiClient.ParameterToString(sid)); // path parameter
            if (since != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "since", since)); // query parameter
            if (offset != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "offset", offset)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V2StreamSidMessageGet", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V2MessageList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (V2MessageList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V2MessageList)));
        }

        /// <summary>
        /// Get messages from an existing stream. A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="offset">No. of messages to skip.  (optional)</param>
        /// <param name="limit">Max No. of messages to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <returns>Task of V2MessageList</returns>
        public async System.Threading.Tasks.Task<V2MessageList> V2StreamSidMessageGetAsync (string sid, long? since, string sessionToken, string keyManagerToken, int? offset = null, int? limit = null)
        {
             ApiResponse<V2MessageList> localVarResponse = await V2StreamSidMessageGetAsyncWithHttpInfo(sid, since, sessionToken, keyManagerToken, offset, limit);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get messages from an existing stream. A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="offset">No. of messages to skip.  (optional)</param>
        /// <param name="limit">Max No. of messages to return. If no value is provided, 50 is the default.  (optional)</param>
        /// <returns>Task of ApiResponse (V2MessageList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V2MessageList>> V2StreamSidMessageGetAsyncWithHttpInfo (string sid, long? since, string sessionToken, string keyManagerToken, int? offset = null, int? limit = null)
        {
            // verify the required parameter 'sid' is set
            if (sid == null)
                throw new ApiException(400, "Missing required parameter 'sid' when calling MessagesApi->V2StreamSidMessageGet");
            // verify the required parameter 'since' is set
            if (since == null)
                throw new ApiException(400, "Missing required parameter 'since' when calling MessagesApi->V2StreamSidMessageGet");
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V2StreamSidMessageGet");
            // verify the required parameter 'keyManagerToken' is set
            if (keyManagerToken == null)
                throw new ApiException(400, "Missing required parameter 'keyManagerToken' when calling MessagesApi->V2StreamSidMessageGet");

            var localVarPath = "./v2/stream/{sid}/message";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sid != null) localVarPathParams.Add("sid", Configuration.ApiClient.ParameterToString(sid)); // path parameter
            if (since != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "since", since)); // query parameter
            if (offset != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "offset", offset)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V2StreamSidMessageGet", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V2MessageList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (V2MessageList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V2MessageList)));
        }

        /// <summary>
        /// PROVISIONAL - Post a message to one existing stream. Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message (see the V2MessageSubmission parameter).  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned.  Regarding authentication, you must either use the sessionToken which was created for delegated app access or both the sessionToken and keyManagerToken together. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Authorization token used to make delegated calls.</param>
        /// <param name="message"></param>
        /// <param name="keyManagerToken">Key Manager authentication token. (optional)</param>
        /// <returns>V2Message</returns>
        public V2Message V3StreamSidMessageCreatePost (string sid, string sessionToken, V2MessageSubmission message, string keyManagerToken = null)
        {
             ApiResponse<V2Message> localVarResponse = V3StreamSidMessageCreatePostWithHttpInfo(sid, sessionToken, message, keyManagerToken);
             return localVarResponse.Data;
        }

        /// <summary>
        /// PROVISIONAL - Post a message to one existing stream. Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message (see the V2MessageSubmission parameter).  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned.  Regarding authentication, you must either use the sessionToken which was created for delegated app access or both the sessionToken and keyManagerToken together. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Authorization token used to make delegated calls.</param>
        /// <param name="message"></param>
        /// <param name="keyManagerToken">Key Manager authentication token. (optional)</param>
        /// <returns>ApiResponse of V2Message</returns>
        public ApiResponse< V2Message > V3StreamSidMessageCreatePostWithHttpInfo (string sid, string sessionToken, V2MessageSubmission message, string keyManagerToken = null)
        {
            // verify the required parameter 'sid' is set
            if (sid == null)
                throw new ApiException(400, "Missing required parameter 'sid' when calling MessagesApi->V3StreamSidMessageCreatePost");
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V3StreamSidMessageCreatePost");
            // verify the required parameter 'message' is set
            if (message == null)
                throw new ApiException(400, "Missing required parameter 'message' when calling MessagesApi->V3StreamSidMessageCreatePost");

            var localVarPath = "./v3/stream/{sid}/message/create";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sid != null) localVarPathParams.Add("sid", Configuration.ApiClient.ParameterToString(sid)); // path parameter
            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter
            if (message != null && message.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(message); // http body (model) parameter
            }
            else
            {
                localVarPostBody = message; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V3StreamSidMessageCreatePost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V2Message>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (V2Message) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V2Message)));
        }

        /// <summary>
        /// PROVISIONAL - Post a message to one existing stream. Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message (see the V2MessageSubmission parameter).  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned.  Regarding authentication, you must either use the sessionToken which was created for delegated app access or both the sessionToken and keyManagerToken together. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Authorization token used to make delegated calls.</param>
        /// <param name="message"></param>
        /// <param name="keyManagerToken">Key Manager authentication token. (optional)</param>
        /// <returns>Task of V2Message</returns>
        public async System.Threading.Tasks.Task<V2Message> V3StreamSidMessageCreatePostAsync (string sid, string sessionToken, V2MessageSubmission message, string keyManagerToken = null)
        {
             ApiResponse<V2Message> localVarResponse = await V3StreamSidMessageCreatePostAsyncWithHttpInfo(sid, sessionToken, message, keyManagerToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// PROVISIONAL - Post a message to one existing stream. Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message (see the V2MessageSubmission parameter).  If the message parameter type is TEXT then the message contains plain text and cannot include formating, hash tags, mentions etc.  If the message parameter type is MessageML then the message contains MessageML which allows for these entities.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned.  Regarding authentication, you must either use the sessionToken which was created for delegated app access or both the sessionToken and keyManagerToken together. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Authorization token used to make delegated calls.</param>
        /// <param name="message"></param>
        /// <param name="keyManagerToken">Key Manager authentication token. (optional)</param>
        /// <returns>Task of ApiResponse (V2Message)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V2Message>> V3StreamSidMessageCreatePostAsyncWithHttpInfo (string sid, string sessionToken, V2MessageSubmission message, string keyManagerToken = null)
        {
            // verify the required parameter 'sid' is set
            if (sid == null)
                throw new ApiException(400, "Missing required parameter 'sid' when calling MessagesApi->V3StreamSidMessageCreatePost");
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V3StreamSidMessageCreatePost");
            // verify the required parameter 'message' is set
            if (message == null)
                throw new ApiException(400, "Missing required parameter 'message' when calling MessagesApi->V3StreamSidMessageCreatePost");

            var localVarPath = "./v3/stream/{sid}/message/create";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sid != null) localVarPathParams.Add("sid", Configuration.ApiClient.ParameterToString(sid)); // path parameter
            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter
            if (message != null && message.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(message); // http body (model) parameter
            }
            else
            {
                localVarPostBody = message; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V3StreamSidMessageCreatePost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V2Message>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (V2Message) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V2Message)));
        }

        /// <summary>
        /// Import messages from other systems into Symphony. Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. Optionally the original message ID can be specified to identify the imported message for the purpose of repeat imports. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>V4ImportResponseList</returns>
        public V4ImportResponseList V4MessageImportPost (string sessionToken, string keyManagerToken, V4MessageImportList messageList)
        {
             ApiResponse<V4ImportResponseList> localVarResponse = V4MessageImportPostWithHttpInfo(sessionToken, keyManagerToken, messageList);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Import messages from other systems into Symphony. Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. Optionally the original message ID can be specified to identify the imported message for the purpose of repeat imports. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>ApiResponse of V4ImportResponseList</returns>
        public ApiResponse< V4ImportResponseList > V4MessageImportPostWithHttpInfo (string sessionToken, string keyManagerToken, V4MessageImportList messageList)
        {
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V4MessageImportPost");
            // verify the required parameter 'keyManagerToken' is set
            if (keyManagerToken == null)
                throw new ApiException(400, "Missing required parameter 'keyManagerToken' when calling MessagesApi->V4MessageImportPost");
            // verify the required parameter 'messageList' is set
            if (messageList == null)
                throw new ApiException(400, "Missing required parameter 'messageList' when calling MessagesApi->V4MessageImportPost");

            var localVarPath = "./v4/message/import";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter
            if (messageList != null && messageList.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(messageList); // http body (model) parameter
            }
            else
            {
                localVarPostBody = messageList; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V4MessageImportPost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V4ImportResponseList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (V4ImportResponseList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V4ImportResponseList)));
        }

        /// <summary>
        /// Import messages from other systems into Symphony. Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. Optionally the original message ID can be specified to identify the imported message for the purpose of repeat imports. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>Task of V4ImportResponseList</returns>
        public async System.Threading.Tasks.Task<V4ImportResponseList> V4MessageImportPostAsync (string sessionToken, string keyManagerToken, V4MessageImportList messageList)
        {
             ApiResponse<V4ImportResponseList> localVarResponse = await V4MessageImportPostAsyncWithHttpInfo(sessionToken, keyManagerToken, messageList);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Import messages from other systems into Symphony. Sends a message to be imported into the system. Allows you to override the timestamp and author of the message with your desired values. The requesting user must have the Content Management role. Also, the requesting user must be a member of the conversation it is importing into. The user that the message is intended to have come from must also be present in the conversation. The intended message timestamp must be a valid time from the past. It cannot be a future timestamp. Optionally the original message ID can be specified to identify the imported message for the purpose of repeat imports. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="messageList"></param>
        /// <returns>Task of ApiResponse (V4ImportResponseList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V4ImportResponseList>> V4MessageImportPostAsyncWithHttpInfo (string sessionToken, string keyManagerToken, V4MessageImportList messageList)
        {
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V4MessageImportPost");
            // verify the required parameter 'keyManagerToken' is set
            if (keyManagerToken == null)
                throw new ApiException(400, "Missing required parameter 'keyManagerToken' when calling MessagesApi->V4MessageImportPost");
            // verify the required parameter 'messageList' is set
            if (messageList == null)
                throw new ApiException(400, "Missing required parameter 'messageList' when calling MessagesApi->V4MessageImportPost");

            var localVarPath = "./v4/message/import";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter
            if (messageList != null && messageList.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(messageList); // http body (model) parameter
            }
            else
            {
                localVarPostBody = messageList; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V4MessageImportPost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V4ImportResponseList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (V4ImportResponseList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V4ImportResponseList)));
        }

        /// <summary>
        /// Post a message to one existing stream. Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message.  The message can be provided as MessageMLV2 or PresentationML. Both formats support Freemarker templates.  The optional parameter \&quot;data\&quot; can be used to provide a JSON payload containing entity data. If the message contains explicit references to entity data (in \&quot;data-entity-id\&quot; element attributes), this parameter is required.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned.  Regarding authentication, you must either use the sessionToken which was created for delegated app access or both the sessionToken and keyManagerToken together. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Authorization token used to make delegated calls.</param>
        /// <param name="message">The message payload in MessageML.</param>
        /// <param name="keyManagerToken">Key Manager authentication token. (optional)</param>
        /// <param name="data">Optional message data in EntityJSON. (optional)</param>
        /// <param name="version">Optional message version in the format \&quot;major.minor\&quot;. If empty, defaults to the latest supported version.  (optional)</param>
        /// <param name="attachment">Optional file attachment. (optional)</param>
        /// <returns>V4Message</returns>
        public V4Message V4StreamSidMessageCreatePost (string sid, string sessionToken, string message, string keyManagerToken = null, string data = null, string version = null, System.IO.Stream attachment = null)
        {
             ApiResponse<V4Message> localVarResponse = V4StreamSidMessageCreatePostWithHttpInfo(sid, sessionToken, message, keyManagerToken, data, version, attachment);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Post a message to one existing stream. Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message.  The message can be provided as MessageMLV2 or PresentationML. Both formats support Freemarker templates.  The optional parameter \&quot;data\&quot; can be used to provide a JSON payload containing entity data. If the message contains explicit references to entity data (in \&quot;data-entity-id\&quot; element attributes), this parameter is required.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned.  Regarding authentication, you must either use the sessionToken which was created for delegated app access or both the sessionToken and keyManagerToken together. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Authorization token used to make delegated calls.</param>
        /// <param name="message">The message payload in MessageML.</param>
        /// <param name="keyManagerToken">Key Manager authentication token. (optional)</param>
        /// <param name="data">Optional message data in EntityJSON. (optional)</param>
        /// <param name="version">Optional message version in the format \&quot;major.minor\&quot;. If empty, defaults to the latest supported version.  (optional)</param>
        /// <param name="attachment">Optional file attachment. (optional)</param>
        /// <returns>ApiResponse of V4Message</returns>
        public ApiResponse< V4Message > V4StreamSidMessageCreatePostWithHttpInfo (string sid, string sessionToken, string message, string keyManagerToken = null, string data = null, string version = null, System.IO.Stream attachment = null)
        {
            // verify the required parameter 'sid' is set
            if (sid == null)
                throw new ApiException(400, "Missing required parameter 'sid' when calling MessagesApi->V4StreamSidMessageCreatePost");
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V4StreamSidMessageCreatePost");
            // verify the required parameter 'message' is set
            if (message == null)
                throw new ApiException(400, "Missing required parameter 'message' when calling MessagesApi->V4StreamSidMessageCreatePost");

            var localVarPath = "./v4/stream/{sid}/message/create";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data", 
                "application/x-www-form-urlencoded"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sid != null) localVarPathParams.Add("sid", Configuration.ApiClient.ParameterToString(sid)); // path parameter
            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter
            if (message != null) localVarFormParams.Add("message", Configuration.ApiClient.ParameterToString(message)); // form parameter
            if (data != null) localVarFormParams.Add("data", Configuration.ApiClient.ParameterToString(data)); // form parameter
            if (version != null) localVarFormParams.Add("version", Configuration.ApiClient.ParameterToString(version)); // form parameter
            if (attachment != null) localVarFileParams.Add("attachment", Configuration.ApiClient.ParameterToFile("attachment", attachment));


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V4StreamSidMessageCreatePost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V4Message>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (V4Message) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V4Message)));
        }

        /// <summary>
        /// Post a message to one existing stream. Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message.  The message can be provided as MessageMLV2 or PresentationML. Both formats support Freemarker templates.  The optional parameter \&quot;data\&quot; can be used to provide a JSON payload containing entity data. If the message contains explicit references to entity data (in \&quot;data-entity-id\&quot; element attributes), this parameter is required.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned.  Regarding authentication, you must either use the sessionToken which was created for delegated app access or both the sessionToken and keyManagerToken together. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Authorization token used to make delegated calls.</param>
        /// <param name="message">The message payload in MessageML.</param>
        /// <param name="keyManagerToken">Key Manager authentication token. (optional)</param>
        /// <param name="data">Optional message data in EntityJSON. (optional)</param>
        /// <param name="version">Optional message version in the format \&quot;major.minor\&quot;. If empty, defaults to the latest supported version.  (optional)</param>
        /// <param name="attachment">Optional file attachment. (optional)</param>
        /// <returns>Task of V4Message</returns>
        public async System.Threading.Tasks.Task<V4Message> V4StreamSidMessageCreatePostAsync (string sid, string sessionToken, string message, string keyManagerToken = null, string data = null, string version = null, System.IO.Stream attachment = null)
        {
             ApiResponse<V4Message> localVarResponse = await V4StreamSidMessageCreatePostAsyncWithHttpInfo(sid, sessionToken, message, keyManagerToken, data, version, attachment);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Post a message to one existing stream. Post a new message to the given stream. The stream can be a chatroom, an IM or a multiparty IM.  You may include an attachment on the message.  The message can be provided as MessageMLV2 or PresentationML. Both formats support Freemarker templates.  The optional parameter \&quot;data\&quot; can be used to provide a JSON payload containing entity data. If the message contains explicit references to entity data (in \&quot;data-entity-id\&quot; element attributes), this parameter is required.  If the message is in MessageML and fails schema validation a client error results  If the message is sent then 200 is returned.  Regarding authentication, you must either use the sessionToken which was created for delegated app access or both the sessionToken and keyManagerToken together. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID</param>
        /// <param name="sessionToken">Authorization token used to make delegated calls.</param>
        /// <param name="message">The message payload in MessageML.</param>
        /// <param name="keyManagerToken">Key Manager authentication token. (optional)</param>
        /// <param name="data">Optional message data in EntityJSON. (optional)</param>
        /// <param name="version">Optional message version in the format \&quot;major.minor\&quot;. If empty, defaults to the latest supported version.  (optional)</param>
        /// <param name="attachment">Optional file attachment. (optional)</param>
        /// <returns>Task of ApiResponse (V4Message)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V4Message>> V4StreamSidMessageCreatePostAsyncWithHttpInfo (string sid, string sessionToken, string message, string keyManagerToken = null, string data = null, string version = null, System.IO.Stream attachment = null)
        {
            // verify the required parameter 'sid' is set
            if (sid == null)
                throw new ApiException(400, "Missing required parameter 'sid' when calling MessagesApi->V4StreamSidMessageCreatePost");
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V4StreamSidMessageCreatePost");
            // verify the required parameter 'message' is set
            if (message == null)
                throw new ApiException(400, "Missing required parameter 'message' when calling MessagesApi->V4StreamSidMessageCreatePost");

            var localVarPath = "./v4/stream/{sid}/message/create";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data", 
                "application/x-www-form-urlencoded"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sid != null) localVarPathParams.Add("sid", Configuration.ApiClient.ParameterToString(sid)); // path parameter
            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter
            if (message != null) localVarFormParams.Add("message", Configuration.ApiClient.ParameterToString(message)); // form parameter
            if (data != null) localVarFormParams.Add("data", Configuration.ApiClient.ParameterToString(data)); // form parameter
            if (version != null) localVarFormParams.Add("version", Configuration.ApiClient.ParameterToString(version)); // form parameter
            if (attachment != null) localVarFileParams.Add("attachment", Configuration.ApiClient.ParameterToFile("attachment", attachment));


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V4StreamSidMessageCreatePost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V4Message>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (V4Message) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V4Message)));
        }

        /// <summary>
        /// Get messages from an existing stream. A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of messages to skip.  (optional)</param>
        /// <param name="limit">Max No. of messages to return. If no value is provided, 50 is the default. The maximum supported value is 500.  (optional)</param>
        /// <returns>V4MessageList</returns>
        public V4MessageList V4StreamSidMessageGet (string sid, long? since, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null)
        {
             ApiResponse<V4MessageList> localVarResponse = V4StreamSidMessageGetWithHttpInfo(sid, since, sessionToken, keyManagerToken, skip, limit);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get messages from an existing stream. A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of messages to skip.  (optional)</param>
        /// <param name="limit">Max No. of messages to return. If no value is provided, 50 is the default. The maximum supported value is 500.  (optional)</param>
        /// <returns>ApiResponse of V4MessageList</returns>
        public ApiResponse< V4MessageList > V4StreamSidMessageGetWithHttpInfo (string sid, long? since, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null)
        {
            // verify the required parameter 'sid' is set
            if (sid == null)
                throw new ApiException(400, "Missing required parameter 'sid' when calling MessagesApi->V4StreamSidMessageGet");
            // verify the required parameter 'since' is set
            if (since == null)
                throw new ApiException(400, "Missing required parameter 'since' when calling MessagesApi->V4StreamSidMessageGet");
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V4StreamSidMessageGet");
            // verify the required parameter 'keyManagerToken' is set
            if (keyManagerToken == null)
                throw new ApiException(400, "Missing required parameter 'keyManagerToken' when calling MessagesApi->V4StreamSidMessageGet");

            var localVarPath = "./v4/stream/{sid}/message";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sid != null) localVarPathParams.Add("sid", Configuration.ApiClient.ParameterToString(sid)); // path parameter
            if (since != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "since", since)); // query parameter
            if (skip != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "skip", skip)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V4StreamSidMessageGet", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V4MessageList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (V4MessageList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V4MessageList)));
        }

        /// <summary>
        /// Get messages from an existing stream. A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of messages to skip.  (optional)</param>
        /// <param name="limit">Max No. of messages to return. If no value is provided, 50 is the default. The maximum supported value is 500.  (optional)</param>
        /// <returns>Task of V4MessageList</returns>
        public async System.Threading.Tasks.Task<V4MessageList> V4StreamSidMessageGetAsync (string sid, long? since, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null)
        {
             ApiResponse<V4MessageList> localVarResponse = await V4StreamSidMessageGetAsyncWithHttpInfo(sid, since, sessionToken, keyManagerToken, skip, limit);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get messages from an existing stream. A caller can fetch all unseen messages by passing the timestamp of the last message seen as the since parameter and the number of messages with the same timestamp value already seen as the skip parameter. This means that every message will be seen exactly once even in the case that an additional message is processed with the same timestamp as the last message returned by the previous call, and the case where there are more than maxMessages with the same timestamp value.  This method is intended for historic queries and is generally reliable but if guaranteed delivery of every message in real time is required then the equivilent firehose method should be called. 
        /// </summary>
        /// <exception cref="SymphonyOSS.RestApiClient.Generated.OpenApi.AgentApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sid">Stream ID </param>
        /// <param name="since">Timestamp of first required message.  This is a long integer value representing milliseconds since Jan 1 1970 </param>
        /// <param name="sessionToken">Session authentication token.</param>
        /// <param name="keyManagerToken">Key Manager authentication token.</param>
        /// <param name="skip">No. of messages to skip.  (optional)</param>
        /// <param name="limit">Max No. of messages to return. If no value is provided, 50 is the default. The maximum supported value is 500.  (optional)</param>
        /// <returns>Task of ApiResponse (V4MessageList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<V4MessageList>> V4StreamSidMessageGetAsyncWithHttpInfo (string sid, long? since, string sessionToken, string keyManagerToken, int? skip = null, int? limit = null)
        {
            // verify the required parameter 'sid' is set
            if (sid == null)
                throw new ApiException(400, "Missing required parameter 'sid' when calling MessagesApi->V4StreamSidMessageGet");
            // verify the required parameter 'since' is set
            if (since == null)
                throw new ApiException(400, "Missing required parameter 'since' when calling MessagesApi->V4StreamSidMessageGet");
            // verify the required parameter 'sessionToken' is set
            if (sessionToken == null)
                throw new ApiException(400, "Missing required parameter 'sessionToken' when calling MessagesApi->V4StreamSidMessageGet");
            // verify the required parameter 'keyManagerToken' is set
            if (keyManagerToken == null)
                throw new ApiException(400, "Missing required parameter 'keyManagerToken' when calling MessagesApi->V4StreamSidMessageGet");

            var localVarPath = "./v4/stream/{sid}/message";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (sid != null) localVarPathParams.Add("sid", Configuration.ApiClient.ParameterToString(sid)); // path parameter
            if (since != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "since", since)); // query parameter
            if (skip != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "skip", skip)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (sessionToken != null) localVarHeaderParams.Add("sessionToken", Configuration.ApiClient.ParameterToString(sessionToken)); // header parameter
            if (keyManagerToken != null) localVarHeaderParams.Add("keyManagerToken", Configuration.ApiClient.ParameterToString(keyManagerToken)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("V4StreamSidMessageGet", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<V4MessageList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (V4MessageList) Configuration.ApiClient.Deserialize(localVarResponse, typeof(V4MessageList)));
        }

    }
}
